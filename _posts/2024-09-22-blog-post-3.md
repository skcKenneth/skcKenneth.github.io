---
title: 'Storing the Sun'
date: 2024-09-22
permalink: /posts/2024/09/blog-post-3/
tags:
  - Mathematical Modeling
  - Python
  - Solar Energy
---

This is a blog post about HiMCM 2021 Problem A. The problem statement can be found [here](https://www.contest.comap.com/highschool/contests/himcm/2021_Problems/2021_HiMCM_Problem_A.pdf). Briefly, the problem is about designing a solar energy storage system for a small town. 

**Problem Background**
======================
An energy storage system allows you to capture electricity, store it as another form
of energy (battery, thermal, mechanical) and then have it available to use when needed. The
purpose of these storage units is to store energy produced during sunny daylight hours for
use when the solar panels do not produce enough energy for the demand (night or cloud
covered), or for storage and transfer of excess energy. Of the solar-powered homes that use an
energy storage system, most use some sort of battery. Some homeowners have only one large
battery, while others may use a “bank of batteries” (two or more batteries connected). Energy
storage can be expensive and so homeowners should choose a system that is appropriate for their
situation.

In choosing an energy storage system there are many criteria to consider. Here are a few of the
most common decision criteria, as well as which battery specifications matter most for each
criterion. 
- To power more of your home at once, you will want a battery with a high **continuous power rating**.
- To power a more energy-intensive appliance (requiring more power in short bursts), your battery should have a high **instantaneous power rating**.
- To run your home for a longer amount of time, look for a battery with a higher **usable capacity**.
- If you want to get the most out of every kilowatt-hour of electricity you put into your battery, look for a battery with a higher **round-trip efficiency**.  

Additional considerations apply for the type of battery.
- Lead-acid (flooded or sealed) and lithium-ion batteries are ideal for a full-time, off-grid supply of different levels of use.
- Lead-acid batteries have been around for a long time and are known for their low prices and reliability.
- Lithium-ion batteries are more expensive, but require no maintenance. Other options are nickel cadmium and flow batteries.
- Look for lithium iron phosphate (LFP) batteries (a type of lithium-ion battery) to get the longest lifetime that you can cycle the most times.
- For the absolute highest safety rating possible (although they are all safe), look to LFP batteries.   

### Requirements
1. Consider the 1600 square-foot off-the-grid home you are planning.
    1. Analyze your solar-power storage requirements by first making a list of questions to determine your energy needs. Discuss the range of possible answers to your questions. To get you started, here are a few questions:
        - How many people will be using energy in this home?
        - What items in the home will need energy and how much energy will they need?
        - When will people in the home use energy? 
    2. Use your analysis from part 1.1., along with the criteria and considerations from the problem background and any other factors you consider important, to develop a mathematical model or algorithm for choosing the "best" battery storage system for your off the-grid home.
    3.  Consider available battery storage options and use your model to choose the best option for your off-the-grid home. The chart at the end of the problem statement provides several, but not all, battery options. Discuss your choice. 
2. Adjust and generalize your model from Requirement 1 so that it is adaptable to individual needs and preferences to choose the best battery storage for any home. Discuss the changes you make to your model. Evaluate your model. 
3.  Recently, researchers in Sweden discovered that cement could be used to store energy. Concrete, which is made with cement, is used to build buildings, sidewalks, bridges, and countless other structures.
    1. Identify some of the advantages and disadvantages of using cement batteries to store solar power. Describe how might you incorporate cement as a battery for your off-the-grid home or for any home? 
    2.  Determine and discuss the additional information you would need in order for you to model and compare the use of cement batteries to currently available batteries for solarpower storage. Note: You are NOT required to create the model.

**Analysis**
=============
To solve the problem, we need to establish mathematical models that can help us choose the best battery storage system for an off-the-grid home. The first step is to analyze the energy needs of the home. We need to determine the energy consumption of the home, the number of people using energy, the items in the home that need energy, and the time when people in the home use energy.

The model we used combines energy demand, solar energy generation, and battery storage dynamics to simulate and evaluate the performance of different battery technologies. This is essentially an energy balance model that calculates how much energy is generated by the solar panels, how much is consumed by the home, and how the battery stores or provides energy.

Let us break down the model into different components.

## Energy Demand Model
The energy demand model calculates how much energy the home consumes based on the appliances used, their power ratings, and the time of day when they are in use.

### Mathematical Formulation
The total energy demand $E_{\text{demand}}$ at any time $t$ is the sum of the energy consumption of each appliance in the home:

$$
E_{\text{demand}}(t) = \sum_{i=1}^{n} P_i\cdot h_i(t) \quad \text{for} \quad t \in [0, T]
$$

Where:
- $P_i$ is the power rating of appliance $i$ in kilowatts (kW).
- $h_i(t)$ is the number of hours appliance $i$ is used at time $t$.

This allows for **time-varying demand**, where appliances may be used more during certain hours (e.g., HVAC systems in the evening or lighting at night).

## Solar Power Generation Model
The solar power generation model calculates how much energy the solar panels generate based on the available sunlight (irradiance), weather conditions, and panel efficiency.

### The Solar Power Equation
The solar power generated at any time $t$ is:

$$
E_{\text{solar}}(t) = A \cdot G(t) \cdot \eta \cdot W(t) \quad \text{for} \quad t \in [0, T]
$$

Where:
- $A$ is the area of the solar panels in square meters ($m^2$).
- $G(t)$ is the solar irradiance at time $t$ in watts per square meter ($kW/m^2$).
- $\eta$ is the efficiency of the solar panels.
- $W(t)$ is the weather factor (a multiplier that accounts for weather conditions).

This model allows for time-varying solar generation depending on the time of day (using irradiance profiles) and stochastic weather effects (random variation in sunlight availability).

## Battery Storage Dynamics
The battery model manages the **state of charge (SOC)** and calculates how much energy is stored in or drawn from the battery depending on whether the solar power generation exceeds or falls short of energy demand.

### Charge/Discharge Dynamics
At any time $t$:
- If solar generation exceeds energy demand, the battery charges:
  $$
    \Delta E_{\text{stored}}(t) = \left(E_{\text{solar}}(t) - E_{\text{demand}}(t)\right) \cdot \eta_{\text{battery}} \quad \text{for} \quad E_{\text{solar}}(t) > E_{\text{demand}}(t)
  $$
- If energy demand exceeds solar generation, the battery discharges:
  $$
    \Delta E_{\text{discharged}}(t) = \left(E_{\text{demand}}(t) - E_{\text{solar}}(t)\right) / \eta_{\text{battery}} \quad \text{for} \quad E_{\text{solar}}(t) < E_{\text{demand}}(t)
  $$

The battery’s state of charge (SOC) is updated based on whether it is being charged or discharged:

$$
SOC(t+1)= SOC(t) + \Delta E_{\text{stored}}(t) - \Delta E_{\text{discharged}}(t)
$$

Where the SOC is bounded by the battery’s capacity:

$$
0 \leq SOC(t) \leq C_{\text{battery}}
$$

This model allows for **dynamic charging and discharging** of the battery based on the energy balance between solar generation and demand.

## Energy Balance and Unmet Demand
At each time step $t$, the system balances energy demand and supply, either storing excess energy in the battery or using stored energy to meet the demand. If both solar generation and battery power are insufficient, unmet demand is recorded.

### Total Unmet Demand
The total unmet demand over the simulation period (e.g., one week) is calculated by summing the unmet energy across all time steps where the battery and solar generation cannot meet the demand:

$$
E_{\text{unmet}} = \sum_{t=0}^{T} \max(0, E_{\text{demand}}(t) - E_{\text{solar}}(t) - \Delta E_{\text{discharged}}(t))
$$

## Sensitivity Analysis
The model was used to perform **sensitivity analysis**, where key parameters such as **battery capacity**, **efficiency**, and **solar panel area** were varied to assess their impact on unmet demand and system performance.

**Solution**
=============
In order to answer the questions in requirements, we break down the problem into smaller parts and solve them one by one.

## Requirement 1.a. Analyze Solar-Power Storage Requirements:
1. How many people will be using energy in this home?
   - Typically, 2-5 people might live in a 1600 square-foot home. More occupants will result in higher energy consumption due to additional appliances and more frequent usage of energy-intensive appliances (e.g., washing machines, heating/cooling systems).
2. What items in the home will need energy, and how much energy will they need?
   - Appliances like refrigerators, HVAC (heating and cooling), lighting, and water heaters consume the most energy.
     - A fridge might consume around 1-2 kWh/day.
     - An HVAC system can consume around 3-6 kWh/day depending on usage.
     - Lights, cooking appliances, and electronics will consume varying amounts depending on daily habits.
   - We need to sum the daily energy consumption of all the major appliances and utilities in the house to determine the total daily energy demand.
3. When will people in the home use energy?
   - Peak energy usage typically occurs in the morning (e.g., for heating, cooking) and in the evening (lighting, HVAC). During the day, energy consumption might be lower if occupants are away from the house, though devices like refrigerators and climate control systems will still use energy.

## Requirement 1.b Develop a Mathematical Model or Algorithm for Choosing the Best Battery:
The mathematical model we implemented takes into account:
- Energy demand of the home (based on appliances and usage).
- Solar panel generation (based on irradiance and weather conditions).
- Battery storage (capacity, efficiency, power output).

The algorithm uses this data to simulate energy consumption, solar energy generation, and battery charge/discharge cycles over time. It calculates unmet energy demand, battery state of charge, and solar excess energy, helping identify the best battery size and type.

## Requirement 1.c Choose the Best Battery Storage System:
We considered several battery storage options (cement, lithium-ion, lead-acid) using the provided data on capacity, efficiency, and cost. Each battery was evaluated based on:
- Unmet demand: Batteries with higher capacity and efficiency (such as lithium-ion) performed better in reducing unmet energy demand.
- Cost: Cement batteries had a lower cost per kWh, but they were less efficient.
- Power output: Cement batteries were ideal for long-term, low-power storage, while lithium-ion handled peak demands better.

## Requirement 2 Adjust and Generalize the Model:
The model was adjusted to make it adaptable to various home sizes, energy needs, and user preferences. Specifically:
- The **HomeEnergyDemand** model was made flexible, allowing the user to define the size of the home, number of occupants, and appliances.
- Users could input specific parameters such as:
  - **Appliance power ratings** and **daily usage patterns**.
  - **Solar panel area** and **efficiency**.
  - **Battery capacity**, efficiency, and cost.

## Requirement 3.a Advantages and Disadvantages of Cement Batteries:
- Advantages:
  - **Cost**: Cement batteries are cheaper since they are integrated into building structures, serving a dual purpose (structural support and energy storage).
  - **Long lifespan**: These batteries may have a longer lifespan as part of the structure, making them a cost-effective solution for long-term energy storage.
  - **Sustainability**: Cement batteries are a greener alternative compared to lithium-ion or lead-acid batteries since they use abundant materials.

- Disadvantages:
  - **Lower efficiency**: Cement batteries typically have a lower round-trip efficiency (~65%) compared to lithium-ion (~90%).
  - **Low power output**: Cement batteries are better for long-term energy storage but are not suitable for handling high peak power demands.
  - **Space requirement**: Cement batteries require larger structures for significant capacity, making them impractical in smaller homes or for high-power applications.

- Incorporating Cement Batteries in the Off-Grid Home:
  - In this off-grid scenario, cement batteries could be used as part of the building foundation or walls to store energy over long periods.
  - For a home that needs steady power throughout cloudy days, the cement battery could handle basic energy needs (like refrigeration, lighting), while a lithium-ion battery could be used to meet peak demand during the evening.

## Requirement 3.b Additional Information for Modeling Cement Batteries:
To model and compare cement batteries to other storage systems, additional information would include:
- **Degradation rate**: How quickly does the cement battery degrade over time compared to lithium-ion and lead-acid batteries?
- **Charge/discharge cycle limits**: How many full charge/discharge cycles can a cement battery handle before its performance deteriorates?
- **Cost per square foot of cement battery**: How does the cost scale when increasing the battery’s capacity through structural additions?

Since I am not someone solve the problem with bare hands, I am going to implement the model in Python and use optimization techniques to find the best battery storage system for the off-the-grid home. 

First, we need to import the necessary libraries:
```python
import numpy as np
import matplotlib.pyplot as plt
```

- `numpy` is used for numerical computations.
- `matplotlib` is used for plotting graphs.

Next, we define the parameters for the plot:
```python
# Setting up Matplotlib
plt.rcParams.update({'font.size': 14})
plt.rcParams.update({'figure.figsize': [20, 18]})
plt.rcParams.update({'figure.autolayout': True})
plt.rcParams.update({'axes.labelsize': 16})
plt.rcParams.update({'axes.titlesize': 24})
plt.rcParams.update({'lines.linewidth': 2})
plt.rcParams.update({'lines.markersize': 10})
```

Thereafter, we define the SolarPanel class that models the solar power generation:
```python
class SolarPanel:
    def __init__(self, area, efficiency):
        self.area = area  # in m²
        self.efficiency = efficiency  # Panel efficiency

    def generate_power(self, irradiance, weather_factor):
        return self.area * irradiance * self.efficiency * weather_factor
```

Then we define the `HomeEnergyDemand` class that models the energy demand of the home:
```python
# Define the HomeEnergyDemand model
class HomeEnergyDemand:
    def __init__(self, base_demand):
        self.base_demand = base_demand  # in kWh

    def demand(self, time_of_day, season_factor):
        # Use a time-of-day factor for peak hours and a season factor for variations
        demand_factor = self._get_demand_factor(time_of_day)
        return self.base_demand * demand_factor * season_factor

    def _get_demand_factor(self, time_of_day):
        if 18 <= time_of_day < 22:  # Evening peak
            return 1.5
        elif 0 <= time_of_day < 6:  # Night low
            return 0.6
        else:
            return 1.0
```

Next, we define the `Battery` class that models the battery storage system:
```python
# Define the Battery model
class Battery:
    def __init__(self, capacity, efficiency, cont_power, inst_power):
        self.capacity = capacity  # in kWh
        self.efficiency = efficiency  # round-trip efficiency
        self.cont_power = cont_power  # continuous power rating in kW
        self.inst_power = inst_power  # instantaneous power rating in kW
        self.soc = 0  # State of charge, initially 0 kWh

    def charge(self, energy):
        charge_energy = min(energy, self.capacity - self.soc)
        self.soc += charge_energy * self.efficiency
        return charge_energy * self.efficiency

    def discharge(self, energy):
        discharge_energy = min(energy, self.soc)
        self.soc -= discharge_energy / self.efficiency
        return discharge_energy / self.efficiency
```

Later on, since I am supposing that the solar panel generates power based on the irradiance and weather conditions, we define the `simulate_energy_system` function that simulates the energy system over a given period of time:

```python
def simulate_energy_system(solar_panel, battery, demand_model, irradiance_profile, weather_profile, hours):
    soc_history = []
    unmet_demand = 0
    
    for hour in range(hours):
        time_of_day = hour % 24  # Get the hour in the day
        irradiance = irradiance_profile[hour]
        weather = weather_profile[hour]
        solar_energy = solar_panel.generate_power(irradiance, weather)
        season_factor = 1  # Placeholder for seasonal variation
        energy_demand = demand_model.demand(time_of_day, season_factor)

        if solar_energy >= energy_demand:
            excess_energy = solar_energy - energy_demand
            battery.charge(excess_energy)
        else:
            shortfall = energy_demand - solar_energy
            battery.discharge(shortfall)
            if battery.soc < shortfall:
                unmet_demand += shortfall - battery.soc

        soc_history.append(battery.soc)

    return soc_history, unmet_demand
```

Now, it is time for example usage of the model. We define the parameters for the solar panel, battery, and home energy demand:
```python
# Define solar panel with area 20 m² and efficiency 18%
solar_panel = SolarPanel(area=20, efficiency=0.18)

# Home base energy demand of 15 kWh/day
home_demand = HomeEnergyDemand(base_demand=15)

# Define a battery with 13.5 kWh capacity, 90% round-trip efficiency, continuous power of 7kW and instantaneous power of 10kW
battery = Battery(capacity=13.5, efficiency=0.9, cont_power=7, inst_power=10)

# Create a 7-day simulation (168 hours)
hours = 168
irradiance_profile = np.clip(np.sin(np.linspace(0, 2 * np.pi, hours)) * 5, 0, None)  # Simulate sinusoidal solar irradiance with max 5 kW/m²
weather_profile = np.random.uniform(0.8, 1.0, hours)  # Weather impact factor between 0.8 and 1.0

# Run the simulation
soc_history, unmet_demand = simulate_energy_system(solar_panel, battery, home_demand, irradiance_profile, weather_profile, hours)

# Plot results
plt.figure(figsize=(20, 12))
plt.plot(soc_history, label='State of Charge (SOC)')
plt.title('Battery State of Charge Over Time')
plt.xlabel('Time (hours)')
plt.ylabel('SOC (kWh)')
plt.legend()
plt.grid(True)
plt.savefig('battery_soc.png')
plt.show()

# Print unmet demand
print(f"Unmet energy demand: {unmet_demand:.2f} kWh")
```

The output of the simulation is a plot showing the battery's state of charge over time and the total unmet energy demand for the 7-day period.

<img src="https://skcKenneth.github.io/ScienceProject//HiMCM2021/ProblemA/battery_soc.png" alt="Battery State of Charge Over Time" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

From the simulation results, we can see how the battery's state of charge varies over time as it charges and discharges based on solar generation and energy demand. The unmet energy demand indicates the amount of energy that could not be supplied by the solar panels and battery, highlighting the need for additional storage capacity or alternative energy sources.

And the output of the unmet demand is:
```
Unmet energy demand: 1677.20 kWh
```

Then one may see that the unmet demand is quite high, indicating that the current battery capacity may not be sufficient to meet the energy needs of the home. This could be due to the limited battery capacity, efficiency, or power ratings, which can be optimized using the model to find the best battery storage system for the off-the-grid home.

We also define the `sensor_analysis` function that performs sensitivity analysis on key parameters such as battery capacity, efficiency, and solar panel area:

```python
# Sensitivity analysis function
def sensitivity_analysis():
    # Test parameters
    battery_capacities = np.linspace(10, 20, 5)  # Vary battery capacity from 10 to 20 kWh
    solar_areas = np.linspace(15, 30, 5)  # Vary solar panel area from 15 to 30 m²
    panel_efficiencies = np.linspace(0.15, 0.25, 5)  # Vary panel efficiency from 15% to 25%
    energy_demands = np.linspace(10, 20, 5)  # Vary home base energy demand from 10 to 20 kWh/day

    # Results containers
    unmet_demand_by_capacity = []
    unmet_demand_by_solar_area = []
    unmet_demand_by_efficiency = []
    unmet_demand_by_energy_demand = []

    # Constant weather and irradiance profiles for consistency
    weather_profile = np.random.uniform(0.8, 1.0, hours)
    irradiance_profile = np.clip(np.sin(np.linspace(0, 2 * np.pi, hours)) * 5, 0, None)

    # Ensure solar_panel is defined before varying parameters
    solar_panel = SolarPanel(area=20, efficiency=0.18)
    home_demand = HomeEnergyDemand(base_demand=15)

    # Vary battery capacity
    for capacity in battery_capacities:
        battery = Battery(capacity=capacity, efficiency=0.9, cont_power=7, inst_power=10)
        soc_history, unmet_demand = simulate_energy_system(solar_panel, battery, home_demand, irradiance_profile, weather_profile, hours)
        unmet_demand_by_capacity.append(unmet_demand)

    # Vary solar panel area
    for area in solar_areas:
        solar_panel = SolarPanel(area=area, efficiency=0.18)
        battery = Battery(capacity=13.5, efficiency=0.9, cont_power=7, inst_power=10)
        soc_history, unmet_demand = simulate_energy_system(solar_panel, battery, home_demand, irradiance_profile, weather_profile, hours)
        unmet_demand_by_solar_area.append(unmet_demand)

    # Vary panel efficiency
    for efficiency in panel_efficiencies:
        solar_panel = SolarPanel(area=20, efficiency=efficiency)
        battery = Battery(capacity=13.5, efficiency=0.9, cont_power=7, inst_power=10)
        soc_history, unmet_demand = simulate_energy_system(solar_panel, battery, home_demand, irradiance_profile, weather_profile, hours)
        unmet_demand_by_efficiency.append(unmet_demand)

    # Vary energy demand
    for demand in energy_demands:
        home_demand = HomeEnergyDemand(base_demand=demand)
        battery = Battery(capacity=13.5, efficiency=0.9, cont_power=7, inst_power=10)
        solar_panel = SolarPanel(area=20, efficiency=0.18)  # Ensure solar_panel is defined
        soc_history, unmet_demand = simulate_energy_system(solar_panel, battery, home_demand, irradiance_profile, weather_profile, hours)
        unmet_demand_by_energy_demand.append(unmet_demand)

    # Plot the sensitivity results
    plt.figure()

    # Plot unmet demand by battery capacity
    plt.subplot(2, 2, 1)
    plt.plot(battery_capacities, unmet_demand_by_capacity, marker='o')
    plt.title('Unmet Demand vs Battery Capacity')
    plt.xlabel('Battery Capacity (kWh)')
    plt.ylabel('Unmet Demand (kWh)')
    plt.grid(True)

    # Plot unmet demand by solar panel area
    plt.subplot(2, 2, 2)
    plt.plot(solar_areas, unmet_demand_by_solar_area, marker='o')
    plt.title('Unmet Demand vs Solar Panel Area')
    plt.xlabel('Solar Panel Area (m²)')
    plt.ylabel('Unmet Demand (kWh)')
    plt.grid(True)

    # Plot unmet demand by panel efficiency
    plt.subplot(2, 2, 3)
    plt.plot(panel_efficiencies, unmet_demand_by_efficiency, marker='o')
    plt.title('Unmet Demand vs Panel Efficiency')
    plt.xlabel('Panel Efficiency (%)')
    plt.ylabel('Unmet Demand (kWh)')
    plt.grid(True)

    # Plot unmet demand by energy demand
    plt.subplot(2, 2, 4)
    plt.plot(energy_demands, unmet_demand_by_energy_demand, marker='o')
    plt.title('Unmet Demand vs Home Energy Demand')
    plt.xlabel('Energy Demand (kWh/day)')
    plt.ylabel('Unmet Demand (kWh)')
    plt.grid(True)

    plt.tight_layout()
    plt.savefig('sensitivity_analysis_1.png')
    plt.show()
```

And we implement the sensitivity analysis function to evaluate the impact of varying battery capacity, solar panel area, panel efficiency, and home energy demand on the unmet energy demand:

```python
# Ensure solar_panel is defined before calling the function
solar_panel = SolarPanel(area=20, efficiency=0.18)
home_demand = HomeEnergyDemand(base_demand=15)
sensitivity_analysis()
```

The output of the sensitivity analysis is a set of plots showing how the unmet energy demand changes with varying battery capacity, solar panel area, panel efficiency, and home energy demand.

<img src="https://skcKenneth.github.io/ScienceProject//HiMCM2021/ProblemA/sensitivity_analysis_1.png" alt="Sensitivity Analysis" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

From the sensitivity analysis, we can observe how changes in key parameters such as battery capacity, solar panel area, efficiency, and home energy demand affect the unmet energy demand. 

Now, we move on to the second part of the sensitivity analysis, where we vary the battery efficiency, continuous power rating, and instantaneous power rating:

```python
# Define the Appliance class to model appliances with varying usage patterns
class Appliance:
    def __init__(self, name, power, usage_hours):
        self.name = name
        self.power = power  # Power rating in kW
        self.usage_hours = usage_hours  # Function defining when the appliance is used

    def energy_usage(self, time_of_day):
        return self.power * self.usage_hours(time_of_day)

# Define the Home class with customizable size, number of occupants, and appliances
class Home:
    def __init__(self, size, occupants, appliances):
        self.size = size  # Size of home in square feet
        self.occupants = occupants  # Number of occupants
        self.appliances = appliances  # List of appliances

    def energy_demand(self, time_of_day):
        # Sum the energy usage of all appliances for a given time of day
        return sum(appliance.energy_usage(time_of_day) for appliance in self.appliances)

# Define the SolarPanel class
class SolarPanel:
    def __init__(self, area, efficiency):
        self.area = area  # Area of solar panels in m²
        self.efficiency = efficiency  # Efficiency of solar panels

    def generate_power(self, irradiance, weather_factor):
        return self.area * irradiance * self.efficiency * weather_factor

# Define the Battery class
class Battery:
    def __init__(self, capacity, efficiency, cont_power, inst_power):
        self.capacity = capacity  # Capacity in kWh
        self.efficiency = efficiency  # Round-trip efficiency
        self.cont_power = cont_power  # Continuous power output in kW
        self.inst_power = inst_power  # Instantaneous power output in kW
        self.soc = 0  # State of charge (initially 0)

    def charge(self, energy):
        charge_energy = min(energy, self.capacity - self.soc)
        self.soc += charge_energy * self.efficiency
        return charge_energy * self.efficiency

    def discharge(self, energy):
        discharge_energy = min(energy, self.soc)
        self.soc -= discharge_energy / self.efficiency
        return discharge_energy / self.efficiency

# Simulate the energy system over time
def simulate_energy_system(home, solar_panel, battery, irradiance_profile, weather_profile, hours):
    soc_history = []
    unmet_demand = 0

    for hour in range(hours):
        time_of_day = hour % 24
        irradiance = irradiance_profile[hour]
        weather = weather_profile[hour]

        solar_energy = solar_panel.generate_power(irradiance, weather)
        energy_demand = home.energy_demand(time_of_day)

        if solar_energy >= energy_demand:
            excess_energy = solar_energy - energy_demand
            battery.charge(excess_energy)
        else:
            shortfall = energy_demand - solar_energy
            battery.discharge(shortfall)
            if battery.soc < shortfall:
                unmet_demand += shortfall - battery.soc

        soc_history.append(battery.soc)

    return soc_history, unmet_demand
```

Nevertheless, we set up the appliances, home, solar panel, and battery for the simulation:

```python
# Example setup
appliances = [
    Appliance('Fridge', 0.15, lambda t: 24),  # 150W fridge running 24/7
    Appliance('AC', 3, lambda t: 8 if 14 <= t < 22 else 0),  # AC used during the day
    Appliance('Lights', 0.1, lambda t: 6 if 18 <= t < 24 else 0)  # Lighting in the evening
]

home = Home(size=1600, occupants=4, appliances=appliances)
solar_panel = SolarPanel(area=20, efficiency=0.18)
battery = Battery(capacity=13.5, efficiency=0.9, cont_power=7, inst_power=10)

# Simulate a week (168 hours)
hours = 168
irradiance_profile = np.clip(np.sin(np.linspace(0, 2 * np.pi, hours)) * 5, 0, None)  # Simulated sinusoidal irradiance
weather_profile = np.random.uniform(0.8, 1.0, hours)  # Weather factor between 0.8 and 1.0

# Run the simulation
soc_history, unmet_demand = simulate_energy_system(home, solar_panel, battery, irradiance_profile, weather_profile, hours)

# Plot results
plt.figure(figsize=(20, 12))
plt.plot(soc_history, label='Battery SOC (kWh)')
plt.title('Battery State of Charge Over Time')
plt.xlabel('Time (hours)')
plt.ylabel('State of Charge (kWh)')
plt.grid(True)
plt.legend()
plt.savefig('battery_soc_2.png')
plt.show()

print(f"Total unmet demand over the week: {unmet_demand:.2f} kWh")
```

The output of the simulation is a plot showing the battery's state of charge over time and the total unmet energy demand for the week.

<img src="https://skcKenneth.github.io/ScienceProject//HiMCM2021/ProblemA/battery_soc_2.png" alt="Battery State of Charge Over Time" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

The total unmet demand over the week is printed as:
```
Total unmet demand over the week: 1476.58 kWh
```

Which in comparison to the previous simulation, the unmet demand is slightly lower, indicating that the energy consumption pattern of the home and the appliances used can significantly impact the energy storage requirements.

Finally, we define the `sensitivity_analysis` function to perform sensitivity analysis on key parameters such as house size, solar panel area, and battery capacity:

```python
# Sensitivity analysis function
def sensitivity_analysis():
    # Test parameters
    house_sizes = np.linspace(1000, 3000, 5)  # Vary house size from 1000 to 3000 sq ft
    solar_areas = np.linspace(15, 30, 5)  # Vary solar panel area from 15 to 30 m²
    battery_capacities = np.linspace(10, 20, 5)  # Vary battery capacity from 10 to 20 kWh

    # Results containers
    unmet_demand_by_size = []
    unmet_demand_by_solar_area = []
    unmet_demand_by_battery_capacity = []

    # Constant weather and irradiance profiles for consistency
    weather_profile = np.random.uniform(0.8, 1.0, hours)
    irradiance_profile = np.clip(np.sin(np.linspace(0, 2 * np.pi, hours)) * 5, 0, None)

    # Vary house size (affects energy demand)
    for size in house_sizes:
        appliances = [
            Appliance('Fridge', 0.15, lambda t: 24),
            Appliance('AC', 3, lambda t: 8 if 14 <= t < 22 else 0),
            Appliance('Lights', 0.1, lambda t: 6 if 18 <= t < 24 else 0)
        ]
        home = Home(size=size, occupants=4, appliances=appliances)
        solar_panel = SolarPanel(area=20, efficiency=0.18)
        battery = Battery(capacity=13.5, efficiency=0.9, cont_power=7, inst_power=10)
        soc_history, unmet_demand = simulate_energy_system(home, solar_panel, battery, irradiance_profile, weather_profile, hours)
        unmet_demand_by_size.append(unmet_demand)

    # Vary solar panel area
    for area in solar_areas:
        appliances = [
            Appliance('Fridge', 0.15, lambda t: 24),
            Appliance('AC', 3, lambda t: 8 if 14 <= t < 22 else 0),
            Appliance('Lights', 0.1, lambda t: 6 if 18 <= t < 24 else 0)
        ]
        home = Home(size=1600, occupants=4, appliances=appliances)
        solar_panel = SolarPanel(area=area, efficiency=0.18)
        battery = Battery(capacity=13.5, efficiency=0.9, cont_power=7, inst_power=10)
        soc_history, unmet_demand = simulate_energy_system(home, solar_panel, battery, irradiance_profile, weather_profile, hours)
        unmet_demand_by_solar_area.append(unmet_demand)

    # Vary battery capacity
    for capacity in battery_capacities:
        appliances = [
            Appliance('Fridge', 0.15, lambda t: 24),
            Appliance('AC', 3, lambda t: 8 if 14 <= t < 22 else 0),
            Appliance('Lights', 0.1, lambda t: 6 if 18 <= t < 24 else 0)
        ]
        home = Home(size=1600, occupants=4, appliances=appliances)
        solar_panel = SolarPanel(area=20, efficiency=0.18)
        battery = Battery(capacity=capacity, efficiency=0.9, cont_power=7, inst_power=10)
        soc_history, unmet_demand = simulate_energy_system(home, solar_panel, battery, irradiance_profile, weather_profile, hours)
        unmet_demand_by_battery_capacity.append(unmet_demand)

    # Plot the sensitivity results
    plt.figure()

    # Plot unmet demand by house size
    plt.subplot(2, 2, 1)
    plt.plot(house_sizes, unmet_demand_by_size, marker='o')
    plt.title('Unmet Demand vs House Size')
    plt.xlabel('House Size (sq ft)')
    plt.ylabel('Unmet Demand (kWh)')
    plt.grid(True)

    # Plot unmet demand by solar panel area
    plt.subplot(2, 2, 2)
    plt.plot(solar_areas, unmet_demand_by_solar_area, marker='o')
    plt.title('Unmet Demand vs Solar Panel Area')
    plt.xlabel('Solar Panel Area (m²)')
    plt.ylabel('Unmet Demand (kWh)')
    plt.grid(True)

    # Plot unmet demand by battery capacity
    plt.subplot(2, 2, 3)
    plt.plot(battery_capacities, unmet_demand_by_battery_capacity, marker='o')
    plt.title('Unmet Demand vs Battery Capacity')
    plt.xlabel('Battery Capacity (kWh)')
    plt.ylabel('Unmet Demand (kWh)')
    plt.grid(True)

    plt.tight_layout()
    plt.savefig('sensitivity_analysis_2.png')
    plt.show()

# Run sensitivity analysis
sensitivity_analysis()
```

The output of the sensitivity analysis is a set of plots showing how the unmet energy demand changes with varying house size, solar panel area, and battery capacity.

<img src="https://skcKenneth.github.io/ScienceProject//HiMCM2021/ProblemA/sensitivity_analysis_2.png" alt="Sensitivity Analysis" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

From the sensitivity analysis, we can observe how changes in key parameters such as house size, solar panel area, and battery capacity affect the unmet energy demand. This information can help optimize the energy storage system for the off-the-grid home based on specific requirements and constraints.

Now, we define a class for each type of battery (cement, lithium-ion, lead-acid) that inherits from the base Battery class:

```python
# Battery class (base)
class Battery:
    def __init__(self, capacity, efficiency, cont_power, inst_power, cost):
        self.capacity = capacity  # Capacity in kWh
        self.efficiency = efficiency  # Round-trip efficiency
        self.cont_power = cont_power  # Continuous power output in kW
        self.inst_power = inst_power  # Instantaneous power output in kW
        self.soc = 0  # State of charge (initially 0 kWh)
        self.cost = cost  # Cost per kWh

    def charge(self, energy):
        charge_energy = min(energy, self.capacity - self.soc)
        self.soc += charge_energy * self.efficiency
        return charge_energy * self.efficiency

    def discharge(self, energy):
        discharge_energy = min(energy, self.soc)
        self.soc -= discharge_energy / self.efficiency
        return discharge_energy / self.efficiency

# Define Cement, Lithium-Ion, and Lead-Acid Batteries
cement_battery = Battery(capacity=50, efficiency=0.65, cont_power=1, inst_power=2, cost=100)
lithium_battery = Battery(capacity=13.5, efficiency=0.9, cont_power=7, inst_power=10, cost=400)
lead_acid_battery = Battery(capacity=10, efficiency=0.8, cont_power=2, inst_power=5, cost=200)

# Example function to simulate a week (168 hours)
def simulate_battery_comparison(batteries, home_demand, solar_panel, irradiance_profile, weather_profile, hours):
    results = {}
    for battery in batteries:
        soc_history, unmet_demand = [], 0
        for hour in range(hours):
            time_of_day = hour % 24
            irradiance = irradiance_profile[hour]
            weather = weather_profile[hour]

            solar_energy = solar_panel.generate_power(irradiance, weather)
            energy_demand = home_demand.energy_demand(time_of_day)

            if solar_energy >= energy_demand:
                excess_energy = solar_energy - energy_demand
                battery.charge(excess_energy)
            else:
                shortfall = energy_demand - solar_energy
                battery.discharge(shortfall)
                if battery.soc < shortfall:
                    unmet_demand += shortfall - battery.soc

            soc_history.append(battery.soc)

        results[battery] = {
            'soc_history': soc_history,
            'unmet_demand': unmet_demand
        }

    return results
```

Furthermore, we run the simulation to compare the performance of cement, lithium-ion, and lead-acid batteries:

```python
# Run the simulation for the three battery types
batteries = [cement_battery, lithium_battery, lead_acid_battery]

# Example of how to generate irradiance and weather profiles (constant for simplicity)
hours = 168  # One week
irradiance_profile = np.clip(np.sin(np.linspace(0, 2 * np.pi, hours)) * 5, 0, None)
weather_profile = np.random.uniform(0.8, 1.0, hours)
```

We can now simulate the energy system using different battery types and compare their performance:
```python
# Example of energy demand model
class HomeEnergyDemand:
    def __init__(self, base_demand):
        self.base_demand = base_demand  # in kWh

    def energy_demand(self, time_of_day):
        # Adjust demand based on time of day (higher in the evening)
        return self.base_demand * (1.5 if 18 <= time_of_day < 22 else 1.0)

# Solar panel class
class SolarPanel:
    def __init__(self, area, efficiency):
        self.area = area  # in m²
        self.efficiency = efficiency  # Panel efficiency

    def generate_power(self, irradiance, weather_factor):
        return self.area * irradiance * self.efficiency * weather_factor

# Simulating a home
home_demand = HomeEnergyDemand(base_demand=15)
solar_panel = SolarPanel(area=20, efficiency=0.18)

# Run the simulation
results = simulate_battery_comparison(batteries, home_demand, solar_panel, irradiance_profile, weather_profile, hours)

# Plot the results
plt.figure(figsize=(20, 12))
for battery in batteries:
    plt.plot(results[battery]['soc_history'], label=f'{battery.capacity} kWh {battery.__class__.__name__} (Unmet: {results[battery]["unmet_demand"]:.2f} kWh)')

plt.title('Battery State of Charge Over Time')
plt.xlabel('Time (hours)')
plt.ylabel('State of Charge (kWh)')
plt.grid(True)
plt.legend()
plt.savefig('battery_soc_3.png')
plt.show()

for battery in batteries:
    print(f"Unmet demand for {battery.capacity} kWh {battery.__class__.__name__}: {results[battery]['unmet_demand']:.2f} kWh")
```

The output of the simulation is a plot showing the state of charge of each battery type over time and the total unmet energy demand for each battery:

<img src="https://skcKenneth.github.io/ScienceProject//HiMCM2021/ProblemA/battery_soc_3.png" alt="Battery State of Charge Over Time" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

In the figure, one may see that the state of charge of each battery type varies over time, reflecting the charging and discharging cycles based on solar generation and energy demand. The total unmet energy demand for each battery type is also printed, showing the performance of each battery in meeting the energy needs of the home.

The unmet demand for each battery type is:
```
Unmet demand for 50 kWh Battery: 1892.61 kWh
Unmet demand for 13.5 kWh Battery: 1890.28 kWh
Unmet demand for 10 kWh Battery: 1891.54 kWh
```

We also define the `sensitivity_analysis` function to perform sensitivity analysis on key parameters such as battery capacity, efficiency, and cost:

```python
# Sensitivity analysis for cement battery capacity, efficiency, and power output
def cement_battery_sensitivity_analysis():
    # Test parameters
    capacities = np.linspace(40, 60, 5)  # Vary capacity from 40 kWh to 60 kWh
    efficiencies = np.linspace(0.5, 0.7, 5)  # Vary efficiency from 50% to 70%
    power_outputs = np.linspace(1, 5, 5)  # Vary continuous power output from 1 to 5 kW

    # Results containers
    unmet_demand_by_capacity = []
    unmet_demand_by_efficiency = []
    unmet_demand_by_power_output = []

    # Constant weather and irradiance profiles for consistency
    weather_profile = np.random.uniform(0.8, 1.0, hours)
    irradiance_profile = np.clip(np.sin(np.linspace(0, 2 * np.pi, hours)) * 5, 0, None)

    # Vary capacity
    for capacity in capacities:
        cement_battery = Battery(capacity=capacity, efficiency=0.65, cont_power=1, inst_power=2, cost=100)
        result = simulate_battery_comparison([cement_battery], home_demand, solar_panel, irradiance_profile, weather_profile, hours)
        unmet_demand = result[cement_battery]['unmet_demand']
        unmet_demand_by_capacity.append(unmet_demand)

    # Vary efficiency
    for efficiency in efficiencies:
        cement_battery = Battery(capacity=50, efficiency=efficiency, cont_power=1, inst_power=2, cost=100)
        result = simulate_battery_comparison([cement_battery], home_demand, solar_panel, irradiance_profile, weather_profile, hours)
        unmet_demand = result[cement_battery]['unmet_demand']
        unmet_demand_by_efficiency.append(unmet_demand)

    # Vary power output
    for power in power_outputs:
        cement_battery = Battery(capacity=50, efficiency=0.65, cont_power=power, inst_power=power + 1, cost=100)
        result = simulate_battery_comparison([cement_battery], home_demand, solar_panel, irradiance_profile, weather_profile, hours)
        unmet_demand = result[cement_battery]['unmet_demand']
        unmet_demand_by_power_output.append(unmet_demand)

    # Plot the sensitivity results
    plt.figure()

    # Unmet demand by capacity
    plt.subplot(3, 1, 1)
    plt.plot(capacities, unmet_demand_by_capacity, marker='o')
    plt.title('Unmet Demand vs Cement Battery Capacity')
    plt.xlabel('Cement Battery Capacity (kWh)')
    plt.ylabel('Unmet Demand (kWh)')
    plt.grid(True)

    # Unmet demand by efficiency
    plt.subplot(3, 1, 2)
    plt.plot(efficiencies, unmet_demand_by_efficiency, marker='o')
    plt.title('Unmet Demand vs Cement Battery Efficiency')
    plt.xlabel('Cement Battery Efficiency (%)')
    plt.ylabel('Unmet Demand (kWh)')
    plt.grid(True)

    # Unmet demand by power output
    plt.subplot(3, 1, 3)
    plt.plot(power_outputs, unmet_demand_by_power_output, marker='o')
    plt.title('Unmet Demand vs Cement Battery Power Output')
    plt.xlabel('Cement Battery Power Output (kW)')
    plt.ylabel('Unmet Demand (kWh)')
    plt.grid(True)

    plt.tight_layout()
    plt.savefig('sensitivity_analysis_3.png')
    plt.show()

# Run sensitivity analysis
cement_battery_sensitivity_analysis()
```

The output of the sensitivity analysis is a set of plots showing how the unmet energy demand changes with varying cement battery capacity, efficiency, and power output.

<img src="https://skcKenneth.github.io/ScienceProject//HiMCM2021/ProblemA/sensitivity_analysis_3.png" alt="Sensitivity Analysis" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

For a better analysis, we also establish the cost analysis to compare the cost-effectiveness of different battery types based on their capacity and cost:

```python
# Cost per kWh delivered (simple cost-benefit analysis)
def cost_per_kwh_delivered(battery):
    energy_delivered = battery.capacity * battery.efficiency  # kWh delivered in one full charge cycle
    return battery.cost / energy_delivered  # Cost per kWh delivered

# Calculate for each battery type
cement_cost_per_kwh = cost_per_kwh_delivered(cement_battery)
lithium_cost_per_kwh = cost_per_kwh_delivered(lithium_battery)
lead_acid_cost_per_kwh = cost_per_kwh_delivered(lead_acid_battery)

print(f"Cement Battery: ${cement_cost_per_kwh:.2f} per kWh delivered")
print(f"Lithium-Ion Battery: ${lithium_cost_per_kwh:.2f} per kWh delivered")
print(f"Lead-Acid Battery: ${lead_acid_cost_per_kwh:.2f} per kWh delivered")
```

The output is the cost per kWh delivered for each battery type, which can be used to compare the cost-effectiveness of different battery technologies.

```
Cement Battery: $3.08 per kWh delivered
Lithium-Ion Battery: $32.92 per kWh delivered
Lead-Acid Battery: $25.00 per kWh delivered
```

```python
# Lifetime cost analysis (10 years)
def lifetime_cost(battery, cycles_per_year, degradation_factor):
    initial_cost = battery.cost * battery.capacity
    lifetime_energy_delivered = battery.capacity * battery.efficiency * cycles_per_year * 10 * degradation_factor
    return initial_cost / lifetime_energy_delivered  # Cost per kWh over 10 years

cycles_per_year = 300  # Assuming daily cycling

cement_lifetime_cost = lifetime_cost(cement_battery, cycles_per_year, 0.95)
lithium_lifetime_cost = lifetime_cost(lithium_battery, cycles_per_year, 0.95)
lead_acid_lifetime_cost = lifetime_cost(lead_acid_battery, cycles_per_year, 0.90)

print(f"Cement Battery Lifetime Cost: ${cement_lifetime_cost:.2f} per kWh")
print(f"Lithium-Ion Battery Lifetime Cost: ${lithium_lifetime_cost:.2f} per kWh")
print(f"Lead-Acid Battery Lifetime Cost: ${lead_acid_lifetime_cost:.2f} per kWh")
```

The output is the lifetime cost per kWh for each battery type over a 10-year period, considering degradation and cycling effects.

```
Cement Battery Lifetime Cost: $0.05 per kWh
Lithium-Ion Battery Lifetime Cost: $0.16 per kWh
Lead-Acid Battery Lifetime Cost: $0.09 per kWh
```

Finally, we establish the hybrid system model that combines solar panels and batteries to meet the energy needs of the home:

```python
def hybrid_system_simulation():
    cement_battery = Battery(capacity=50, efficiency=0.65, cont_power=1, inst_power=2, cost=100)
    lithium_battery = Battery(capacity=13.5, efficiency=0.9, cont_power=7, inst_power=10, cost=400)

    # Simulate hybrid system
    batteries = [cement_battery, lithium_battery]
    results = simulate_battery_comparison(batteries, home_demand, solar_panel, irradiance_profile, weather_profile, hours)

    # Print results for both
    for battery in batteries:
        print(f"{battery.capacity} kWh {battery.__class__.__name__}: Unmet demand = {results[battery]['unmet_demand']:.2f} kWh")

# Run hybrid system simulation
hybrid_system_simulation()
```

The output of the hybrid system simulation shows the unmet energy demand for each battery type in the hybrid system, allowing for a comparison of their performance.

```
50 kWh Battery: Unmet demand = 1892.61 kWh
13.5 kWh Battery: Unmet demand = 1890.28 kWh
```

## Limitations
While the mathematical model provides a solid foundation for evaluating solar power and battery storage systems, there are several limitations that should be considered:

#### Simplified Solar Irradiance and Weather Modeling:
The model uses a sinusoidal function for solar irradiance and a random factor for weather variations. In reality, solar irradiance varies based on location, season, cloud cover, and other meteorological factors. A more detailed weather model (with real-world irradiance data) would provide more accurate results.

#### Static Appliance Usage Patterns:
The appliance usage patterns in the model are predefined and static. In real-life scenarios, energy consumption can vary based on unpredictable human behavior, seasonal factors, and changing lifestyle needs. For example, during holidays or extreme weather, demand might be higher or lower than modeled.

#### Battery Degradation Over Time:
The model does not account for battery degradation, which is a significant factor in real-world applications. Batteries lose capacity and efficiency over time, affecting both energy storage and cost-effectiveness. Including battery degradation curves would make the model more realistic, especially in long-term simulations.

#### Exclusion of Power Conversion Losses:
The model does not account for losses due to power converters, such as inverters (DC to AC) and charge controllers. These components introduce energy losses (usually between 5% and 15%) that reduce the overall system efficiency.

#### Assumption of Continuous Power Supply:
The model assumes a continuous power output from the solar panels and batteries. However, real-world solar energy systems might experience brief disruptions (e.g., due to maintenance or equipment failure), which are not reflected in the simulation.

#### Lack of Real-World Cost Fluctuations:
Battery costs and solar panel prices fluctuate based on market trends, technological advancements, and geographical location. The model uses static cost figures, which may not fully reflect future changes in the cost of batteries and solar technologies.

#### Grid Integration and Backup Systems:
The model assumes an off-grid scenario. However, many real-world solar energy systems are grid-connected, allowing homeowners to sell excess energy or buy additional energy during low solar generation periods. This flexibility is not accounted for in the current model.

**Conclusion**
===============
The mathematical model developed for evaluating the solar power storage needs of an off-grid 1600 square-foot home provides a robust framework for analyzing the performance of various battery storage options, including cement, lithium-ion, and lead-acid batteries. Through detailed simulations and sensitivity analyses, the model evaluates key factors such as energy demand, solar power generation, battery capacity, and efficiency.

The results of the simulations reveal important trade-offs:
- Cement batteries offer a promising and cost-effective solution for long-term energy storage but are less efficient and have lower power output compared to lithium-ion batteries. They are best suited for homes with steady, low-power energy needs, and their integration into building structures provides additional value.
- Lithium-ion batteries, with their high efficiency and ability to handle peak power demands, remain the most reliable choice for homes requiring frequent high-power outputs. However, they come with higher upfront costs compared to cement and lead-acid batteries.
- Lead-acid batteries offer lower initial costs but suffer from faster degradation and lower efficiency, making them less ideal for long-term, high-demand applications.
- The sensitivity analysis highlighted the importance of battery capacity and efficiency in reducing unmet energy demand. For homes with higher energy needs, increasing battery capacity significantly reduces the risk of power shortages during low solar generation periods.

Finally, a hybrid system combining cement and lithium-ion batteries could offer a balanced approach. Cement batteries can handle long-term storage needs, while lithium-ion batteries manage high-demand periods, providing a cost-effective and efficient energy solution for off-grid homes.

While the model offers valuable insights, it is important to consider the limitations, such as simplified solar and weather modeling, exclusion of battery degradation, and lack of real-world grid integration. Despite these limitations, the model serves as a useful tool for assessing battery performance and guiding the selection of optimal energy storage systems for off-grid solar-powered homes.