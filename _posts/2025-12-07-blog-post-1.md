---
title: "Why 'Good Enough' is the New Perfect: An Introduction to Heuristics"
date: 2025-12-07
permalink: /posts/2025/12/blog-post-heuristics-intro/
tags:
  - Heuristics
  - Decision Theory
  - Bounded Rationality
  - Optimization
  - Philosophy of Science
comments: true
---

Imagine you are standing in front of a vending machine. You are hungry, and you have exactly one minute before your bus arrives. Inside, there are 40 different snacks—chips, chocolates, nuts, granola bars. 

> A **mathematician** might say: *"To make the optimal choice, I must calculate the nutritional value per dollar of every item, weighted by my current craving level and the likelihood of the chocolate melting in my pocket."*

By the time they finish that calculation, the bus has left.

>A **normal person** says: *"I like chocolate. That KitKat looks good. I’ll take it."* They get the snack and catch the bus.

This scenario highlights the central tension of decision-making: the battle between **Optimality** (finding the absolute best solution) and **Efficiency** (finding a solution that works, right now). In the world of computer science and operations research, the tools we use to make these fast, practical decisions are called **Heuristics**.

For a long time, I wrote about how to model problems perfectly using complex equations. But reality rarely gives us the luxury of perfection. Today, I want to take a break from the calculus of "best" and explore the philosophy of "good enough." 

Welcome to the world of Heuristics.

**TL;DR:** In messy, time-bound decisions, "good enough" beats "perfect." Heuristics are fast rules—greedy climbs, local tweaks, random jumps, population mixes, swarm signals—that trade exhaustive calculation for useful answers. They win when you set clear thresholds, cap effort, and keep feedback loops so the shortcuts adapt.

### Heuristic Starter Pack (30-Second Tour)

Greedy grabs the best-looking move now—speedy but prone to local traps. Local search nudges a solution and keeps the better one. Simulated annealing is local search with occasional "worse" moves to escape traps. Genetic algorithms keep a population of answers, mixing and mutating them. Ant colony methods send many tiny agents to explore and reinforce promising routes like pheromone trails.

### Where Heuristics Already Run Your Day

Maps reroute mid-drive using shortcuts to approximate the best path without recomputing every road. Spam filters score words, sender history, and clicks to stay fast enough to keep your inbox sane. Search autocomplete leans on frequency, your history, and even time of day. Swiping on dating apps relies on quick personal rules. Even your laptop cache guesses what you’ll need before you ask.

### The Trap of "Straight-A" Thinking

In school, we are trained to believe that every problem has one right answer. If $2x = 4$, then $x$ must be $2$. If you answer $1.9$, you are wrong.

This is **Straight-A Thinking**. It works beautifully for textbook problems where the world is closed, neat, and defined. But the moment you step into the real world—or into complex computing problems—this thinking becomes a trap.

In computer science, there is a class of problems called **NP-Hard**—puzzles so complex that even the fastest supercomputers would take millions of years to solve perfectly. Think of the Traveling Salesman (shortest route through 100 cities), the Knapsack (most value without breaking the bag), or School Timetabling (no two teachers in the same room at once).

If you try to solve these perfectly, you freeze. You become like the mathematician at the vending machine, paralyzed by the need for the "correct" answer while the bus drives away.

### Enter the Heuristic: The Smart Shortcut

The word *heuristic* comes from the Greek word *eurisko*, meaning "I find" or "I discover" (the same root as *Eureka!*). 

A heuristic is a **rule of thumb**. It is a mental shortcut that simplifies a complex problem. It doesn’t guarantee the *perfect* solution, but it guarantees a *good* solution in a reasonable amount of time.

Let’s look at the difference:

| **The Optimizer (Algorithm)** | **The Heuristic (Shortcut)** |
| :--- | :--- |
| Checks every single item on the menu. | "I usually like chicken, so I'll look at the chicken dishes first." |
| Calculates the exact distance of every possible route on a map. | "I'll just head in the general direction of the destination." |
| **Guarantees:** The absolute best result. | **Guarantees:** A pretty good result, quickly. |
| **Cost:** High (Time & Energy). | **Cost:** Low. |

### Why "Good Enough" is Actually Rational

In the 1950s, a Nobel Prize-winning economist named **Herbert Simon** introduced a revolutionary idea called **Bounded Rationality**. 

He argued that humans aren't irrational just because we don't calculate everything perfectly. We are *rationally* irrational. We have limited brains (processing power) and limited time. Therefore, the most logical thing to do is to stop searching once we find something that meets our needs.

He called this **Satisficing** (combining *satisfy* + *suffice*). Optimizing is hunting for the single sharpest needle in the haystack. Satisficing is grabbing a needle sharp enough to sew with—so you finish the shirt before the day ends.

### The "Greedy" Strategy

One of the most famous heuristics in computer science is the **Greedy Algorithm**. Its philosophy is simple: *Always make the choice that looks best right now.*

Imagine you are hiking up a mountain in thick fog. You want to reach the highest peak, but you can't see the top. What do you do?

A **Greedy Heuristic** says: "Look at your feet. Step in the direction that goes up the steepest." The upside is speed—you start climbing immediately. The downside is myopia—you may summit a small hill and miss the real mountain across the valley.

We will explore this "Mountain Problem" (Fitness Landscapes) in the next post. But even with its flaws, the Greedy strategy is often better than standing still and trying to calculate the topology of the entire mountain range.

#### A 12-Line Greedy Heuristic (Coin Change)

Try this mental model in Python or pseudocode:

```python
coins = [25, 10, 5, 1]  # US cents
amount = 63
take = []
for c in coins:
    while amount >= c:
        take.append(c)
        amount -= c
print(take)  # -> [25, 25, 10, 1, 1, 1]
```

It grabs the biggest coin first, which is optimal for U.S. coins but fails for some currencies (a nice reminder that heuristics are context-sensitive).

### When Heuristics Backfire

Local traps can strand you on a "good-enough" hill while the real peak is elsewhere. Biased signals (like a spam filter over-weighting one keyword, or a hiring rule echoing past bias) skew outcomes. And shifting environments mean a pricing rule that worked last year can fail during a market shock.

### Guardrails for Using Heuristics

Decide what "good enough" means (time saved, cost, accuracy) and cap computation so you ship instead of spiral. Add randomness or restarts to hop out of local optima. Track regret—the gap to the theoretical best—to stay honest. Keep a feedback loop so the heuristic adapts when conditions change.

### Mini-Case: Elevator Scheduling

Elevator control often uses a "stay with the crowd" heuristic: cars dwell longer where calls cluster, then sweep in the dominant direction (up in the morning, down at close). It minimizes wait time without simulating every passenger path. When calls are sparse and erratic, lone riders can wait too long—adding a time cap or occasional sweep in the opposite direction softens the failure.

### Your Turn: The "2-Rule" Challenge

To understand heuristics, you have to catch yourself using them. 

**The Challenge:** 
Next time you have to make a decision with too many options (like choosing a movie on Netflix), catch yourself. Are you reading every review—optimizing—or using a rule like "If it has an actor I like, I click play"—a heuristic?

Heuristics aren't lazy. They are the software that allows our brains to function in a complex, chaotic world. Over the next few posts, we are going to open up this toolbox. We will look at how **ants** use heuristics to build bridges, how **metals** use heat to solve math problems, and why **randomness** might be the smartest strategy of all.

**Next Up:** *Climbing Invisible Mountains: How Algorithms Get Lost (and Found).*
